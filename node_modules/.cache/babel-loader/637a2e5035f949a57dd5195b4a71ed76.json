{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n\n/* eslint-disable prefer-const */\n\n/* eslint-disable valid-jsdoc */\n\n/* eslint-disable jsdoc/require-param */\n\n\nimport { withInRange, logBase, markerAnimate, PolarArc, firstToLowerCase } from '../../common/utils/helper';\nimport { valueToCoefficient, CoefficientToVector, valueToPolarCoefficient } from '../../common/utils/helper';\nimport { PathOption } from '@syncfusion/ej2-svg-base';\nimport { PolarRadarPanel } from '../axis/polar-radar-panel';\nimport { pointRender } from '../../common/model/constants';\nimport { Animation, isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * `PolarSeries` module is used to render the polar series.\n */\n\nvar PolarSeries =\n/** @class */\nfunction (_super) {\n  __extends(PolarSeries, _super);\n\n  function PolarSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Render Polar Series.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  PolarSeries.prototype.render = function (series, xAxis, yAxis, inverted) {\n    var seriesType = firstToLowerCase(series.drawType);\n    var yAxisMin = yAxis.minimum;\n    var yAxisMax = yAxis.maximum;\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var visiblePoint = _a[_i];\n      visiblePoint.visible = visiblePoint.visible && !(!isNullOrUndefined(yAxisMin) && visiblePoint.yValue < yAxisMin || !isNullOrUndefined(yAxisMax) && visiblePoint.yValue > yAxisMax);\n    }\n\n    if (series.points.length) {\n      if (series.drawType.indexOf('Column') > -1) {\n        this.columnDrawTypeRender(series, xAxis, yAxis);\n      } else {\n        series.chart[seriesType + 'SeriesModule'].render(series, xAxis, yAxis, inverted);\n      }\n    }\n  };\n  /**\n   * Render Column DrawType.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  PolarSeries.prototype.columnDrawTypeRender = function (series, xAxis, yAxis) {\n    var options;\n    var argsData;\n    var startAngle;\n    var endAngle;\n    var itemCurrentXPos;\n    var radius;\n    var inversedValue;\n    var pointStartAngle;\n    var pointEndAngle;\n    var x1;\n    var x2;\n    var y1;\n    var y2;\n    var startValue;\n    var endValue;\n    var innerRadius;\n    var min = xAxis.actualRange.min;\n    var centerX = series.clipRect.width / 2 + series.clipRect.x;\n    var dStartX;\n    var dStartY;\n    var centerY = series.clipRect.height / 2 + series.clipRect.y;\n    var dEndX;\n    var dEndY;\n    var isRangeColumn = series.drawType === 'RangeColumn';\n    var isPolar = series.type === 'Polar';\n    var isLogAxis = yAxis.valueType === 'Logarithmic';\n    var isStacking = series.drawType === 'StackingColumn';\n    var direction = '';\n    var sumofYValues = 0;\n    var arcValue;\n    var interval = (series.points[1] ? series.points[1].xValue : 2 * series.points[0].xValue) - series.points[0].xValue;\n    var isInverse = xAxis.isAxisInverse; //customer issue ID-I249730, Polar columnSeries in OnTicks with inversed axis\n\n    var ticks = xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks' ? 0 : isInverse ? -interval / 2 : interval / 2;\n    var rangeInterval = xAxis.valueType === 'DateTime' ? xAxis.dateTimeInterval : 1;\n    this.getSeriesPosition(series);\n    var position = isInverse ? series.rectCount - 1 - series.position : series.position;\n\n    do {\n      sumofYValues += rangeInterval;\n      min += rangeInterval;\n    } while (min <= xAxis.actualRange.max - (xAxis.valueType === 'Category' ? 0 : 1));\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n      point.symbolLocations = [];\n      point.regions = [];\n\n      if (point.visible && withInRange(series.points[point.index - 1], point, series.points[point.index + 1], series)) {\n        inversedValue = isInverse ? xAxis.visibleRange.max - point.xValue : point.xValue - xAxis.visibleRange.min;\n        itemCurrentXPos = inversedValue + (interval / series.rectCount * position - ticks) + sumofYValues / 360 * xAxis.startAngle;\n        itemCurrentXPos = itemCurrentXPos / sumofYValues;\n        startAngle = 2 * Math.PI * (itemCurrentXPos + xAxis.startAngle);\n        endAngle = 2 * Math.PI * (itemCurrentXPos + xAxis.startAngle + interval / series.rectCount / sumofYValues);\n\n        if (startAngle === 0 && endAngle === 0) {\n          endAngle = 2 * Math.PI;\n          arcValue = '1';\n        } else {\n          arcValue = '0';\n        }\n\n        pointStartAngle = startAngle;\n        pointEndAngle = endAngle;\n        startAngle = startAngle - 0.5 * Math.PI + series.columnSpacing / 2;\n        endAngle = endAngle - 0.5 * Math.PI - 0.000001 - series.columnSpacing / 2;\n\n        if (isStacking || isRangeColumn) {\n          startValue = isRangeColumn ? point.low : series.stackedValues.startValues[point.index];\n          endValue = isRangeColumn ? point.high : series.stackedValues.endValues[point.index];\n          endValue = isLogAxis ? logBase(endValue === 0 ? 1 : endValue, yAxis.logBase) : endValue;\n          endValue = endValue > yAxis.actualRange.max ? yAxis.actualRange.max : endValue;\n        } else {\n          startValue = yAxis.visibleRange.min;\n          endValue = point.yValue > yAxis.actualRange.max ? yAxis.actualRange.max : point.yValue;\n        }\n\n        radius = startValue === endValue ? 0 : series.chart.radius * valueToCoefficient(endValue, yAxis);\n        x1 = centerX + radius * Math.cos(startAngle);\n        x2 = centerX + radius * Math.cos(endAngle);\n        y1 = centerY + radius * Math.sin(startAngle);\n        y2 = centerY + radius * Math.sin(endAngle);\n        innerRadius = series.chart.radius * valueToCoefficient(startValue === 0 && yAxis.visibleRange.min !== 0 ? yAxis.visibleRange.min : startValue, yAxis);\n        dStartX = centerX + innerRadius * Math.cos(startAngle);\n        dStartY = centerY + innerRadius * Math.sin(startAngle);\n        dEndX = centerX + innerRadius * Math.cos(endAngle);\n        dEndY = centerY + innerRadius * Math.sin(endAngle);\n\n        if (isPolar) {\n          direction = 'M' + ' ' + x1 + ' ' + y1 + ' ' + 'A' + ' ' + radius + ' ' + radius + ' ' + '0' + ' ' + arcValue + ' ' + 1 + ' ' + x2 + ' ' + y2 + ' ' + 'L' + ' ' + dEndX + ' ' + dEndY + ' ' + 'A' + ' ' + innerRadius + ' ' + innerRadius + ' ' + '1' + ' ' + '0' + ' ' + '0' + ' ' + dStartX + ' ' + dStartY + ' ' + 'Z';\n        } else {\n          direction = 'M' + ' ' + x1 + ' ' + y1 + ' ' + 'L' + ' ' + x2 + ' ' + y2 + ' ' + 'L ' + dEndX + ' ' + dEndY + ' ' + 'L' + ' ' + dStartX + ' ' + dStartY + ' ' + 'Z';\n        }\n\n        point.regionData = new PolarArc(pointStartAngle, pointEndAngle, innerRadius, radius, itemCurrentXPos);\n        argsData = this.triggerEvent(series.chart, series, point);\n        options = new PathOption(series.chart.element.id + '_Series_' + series.index + '_Point_' + point.index, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.dashArray, direction);\n\n        if (!argsData.cancel) {\n          this.appendLinePath(options, series, '');\n\n          if (isPolar) {\n            point.symbolLocations.push({\n              x: centerX + radius * Math.cos(startAngle + (endAngle - startAngle) / 2),\n              y: centerY + radius * Math.sin(startAngle + (endAngle - startAngle) / 2)\n            });\n\n            if (isRangeColumn) {\n              point.symbolLocations.push({\n                x: centerX + innerRadius * Math.cos(startAngle + (endAngle - startAngle) / 2),\n                y: centerY + innerRadius * Math.sin(startAngle + (endAngle - startAngle) / 2)\n              });\n            }\n          } else {\n            point.symbolLocations.push({\n              x: (x1 + x2) / 2,\n              y: (y1 + y2) / 2\n            });\n\n            if (isRangeColumn) {\n              point.symbolLocations.push({\n                x: (dEndX + dStartX) / 2,\n                y: (dEndY + dStartY) / 2\n              });\n            }\n          }\n        }\n      }\n    }\n\n    this.renderMarker(series);\n    series.isRectSeries = true;\n  };\n  /**\n   * To trigger the point rendering event.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  PolarSeries.prototype.triggerEvent = function (chart, series, point) {\n    var argsData = {\n      cancel: false,\n      name: pointRender,\n      series: series,\n      point: point,\n      fill: series.setPointColor(point, series.interior),\n      border: series.setBorderColor(point, {\n        width: series.border.width,\n        color: series.border.color\n      })\n    };\n    chart.trigger(pointRender, argsData);\n    point.color = argsData.fill;\n    return argsData;\n  };\n  /** get position for column drawtypes\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  PolarSeries.prototype.getSeriesPosition = function (series) {\n    var chart = series.chart;\n    var seriesCollection = [];\n    var stackingGroup = [];\n    var vSeries = {\n      rectCount: 0,\n      position: null\n    };\n\n    for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n      var series_1 = _a[_i];\n\n      if (series_1.visible && (series_1.type === 'Polar' || series_1.type === 'Radar') && series_1.drawType.indexOf('Column') !== -1) {\n        seriesCollection.push(series_1);\n      }\n    }\n\n    for (var i = 0; i < seriesCollection.length; i++) {\n      var series_2 = seriesCollection[i];\n\n      if (series_2.drawType.indexOf('Stacking') !== -1) {\n        if (series_2.stackingGroup) {\n          if (stackingGroup[series_2.stackingGroup] === undefined) {\n            series_2.position = vSeries.rectCount;\n            stackingGroup[series_2.stackingGroup] = vSeries.rectCount++;\n          } else {\n            series_2.position = stackingGroup[series_2.stackingGroup];\n          }\n        } else {\n          if (vSeries.position === null) {\n            series_2.position = vSeries.rectCount;\n            vSeries.position = vSeries.rectCount++;\n          } else {\n            series_2.position = vSeries.position;\n          }\n        }\n      } else {\n        series_2.position = vSeries.rectCount++;\n      }\n    }\n\n    for (var i = 0; i < seriesCollection.length; i++) {\n      var value = seriesCollection[i];\n      value.rectCount = vSeries.rectCount;\n    }\n  };\n  /**\n   * Animates the series.\n   *\n   * @param  {Series} series - Defines the series to animate.\n   * @returns {void}\n   */\n\n\n  PolarSeries.prototype.doAnimation = function (series) {\n    var duration = series.animation.duration;\n    var delay = series.animation.delay;\n    var rectElements = series.seriesElement.childNodes;\n    var count = 1;\n\n    if (series.drawType === 'Scatter') {\n      for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n        var point = _a[_i];\n\n        if (!point.symbolLocations.length || !rectElements[count]) {\n          continue;\n        }\n\n        markerAnimate(rectElements[count], delay, duration, series, point.index, point.symbolLocations[0], false);\n        count++;\n      }\n    } else {\n      for (count = 1; count < rectElements.length; count++) {\n        this.doPolarRadarAnimation(rectElements[count], delay, duration, series);\n      }\n    }\n  };\n  /**\n   * To do the Polar Radar draw type column animation.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  PolarSeries.prototype.doPolarRadarAnimation = function (animateElement, delay, duration, series) {\n    var chartcenterX = series.clipRect.width / 2 + series.clipRect.x;\n    var chartcenterY = series.clipRect.height / 2 + series.clipRect.y;\n    var elementHeight = 0;\n    animateElement.style.visibility = 'hidden';\n    new Animation({}).animate(animateElement, {\n      duration: duration,\n      delay: delay,\n      progress: function (args) {\n        if (args.timeStamp > args.delay) {\n          args.element.style.visibility = 'visible';\n          elementHeight = (args.timeStamp - args.delay) / args.duration;\n          animateElement.setAttribute('transform', 'translate(' + chartcenterX + ' ' + chartcenterY + ') scale(' + elementHeight + ') translate(' + -chartcenterX + ' ' + -chartcenterY + ')');\n        }\n      },\n      end: function () {\n        animateElement.style.visibility = 'visible';\n        animateElement.removeAttribute('transform');\n        series.chart.trigger('animationComplete', {\n          series: series.chart.isBlazor ? {} : series\n        });\n      }\n    });\n  }; // path calculation for isInversed polar area series\n\n\n  PolarSeries.prototype.getPolarIsInversedPath = function (xAxis, endPoint) {\n    var vector;\n    var x1;\n    var y1;\n    var chart = this.chart;\n    var radius = chart.radius;\n    var direction = endPoint;\n    var circleRotate = xAxis.isAxisInverse ? '1 1 ' : '1 0 ';\n    vector = CoefficientToVector(valueToPolarCoefficient(xAxis.visibleLabels[0].value, xAxis), this.startAngle);\n    x1 = this.centerX + radius * vector.x;\n    y1 = this.centerY + radius * vector.y;\n    return direction += 'L ' + x1 + ' ' + y1 + ' A ' + radius + ' ' + radius + ' 0 ' + circleRotate + x1 + ' ' + (this.centerY + radius) + ' A ' + radius + ' ' + radius + ' 0 ' + circleRotate + x1 + ' ' + y1 + ' ';\n  };\n  /**\n   * Get module name.\n   */\n\n\n  PolarSeries.prototype.getModuleName = function () {\n    /**\n     * Returns the module name of the series\n     */\n    return 'PolarSeries';\n  };\n  /**\n   * To destroy the polar series.\n   *\n   * @returns {void}\n   * @private\n   */\n\n\n  PolarSeries.prototype.destroy = function () {\n    /**\n     * Destroy method performed here\n     */\n  };\n\n  return PolarSeries;\n}(PolarRadarPanel);\n\nexport { PolarSeries };","map":{"version":3,"sources":["/Users/altynbekkuat/Desktop/reactAnalyt/node_modules/@syncfusion/ej2-react-charts/node_modules/@syncfusion/ej2-charts/src/chart/series/polar-series.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","withInRange","logBase","markerAnimate","PolarArc","firstToLowerCase","valueToCoefficient","CoefficientToVector","valueToPolarCoefficient","PathOption","PolarRadarPanel","pointRender","Animation","isNullOrUndefined","PolarSeries","_super","apply","arguments","render","series","xAxis","yAxis","inverted","seriesType","drawType","yAxisMin","minimum","yAxisMax","maximum","_i","_a","points","length","visiblePoint","visible","yValue","indexOf","columnDrawTypeRender","chart","options","argsData","startAngle","endAngle","itemCurrentXPos","radius","inversedValue","pointStartAngle","pointEndAngle","x1","x2","y1","y2","startValue","endValue","innerRadius","min","actualRange","centerX","clipRect","width","x","dStartX","dStartY","centerY","height","y","dEndX","dEndY","isRangeColumn","isPolar","type","isLogAxis","valueType","isStacking","direction","sumofYValues","arcValue","interval","xValue","isInverse","isAxisInverse","ticks","labelPlacement","rangeInterval","dateTimeInterval","getSeriesPosition","position","rectCount","max","point","symbolLocations","regions","index","visibleRange","Math","PI","columnSpacing","low","stackedValues","startValues","high","endValues","cos","sin","regionData","triggerEvent","element","id","fill","border","color","opacity","dashArray","cancel","appendLinePath","push","renderMarker","isRectSeries","name","setPointColor","interior","setBorderColor","trigger","seriesCollection","stackingGroup","vSeries","visibleSeries","series_1","i","series_2","undefined","value","doAnimation","duration","animation","delay","rectElements","seriesElement","childNodes","count","doPolarRadarAnimation","animateElement","chartcenterX","chartcenterY","elementHeight","style","visibility","animate","progress","args","timeStamp","setAttribute","end","removeAttribute","isBlazor","getPolarIsInversedPath","endPoint","vector","circleRotate","visibleLabels","getModuleName","destroy"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n/* eslint-disable prefer-const */\n/* eslint-disable valid-jsdoc */\n/* eslint-disable jsdoc/require-param */\nimport { withInRange, logBase, markerAnimate, PolarArc, firstToLowerCase } from '../../common/utils/helper';\nimport { valueToCoefficient, CoefficientToVector, valueToPolarCoefficient } from '../../common/utils/helper';\nimport { PathOption } from '@syncfusion/ej2-svg-base';\nimport { PolarRadarPanel } from '../axis/polar-radar-panel';\nimport { pointRender } from '../../common/model/constants';\nimport { Animation, isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * `PolarSeries` module is used to render the polar series.\n */\nvar PolarSeries = /** @class */ (function (_super) {\n    __extends(PolarSeries, _super);\n    function PolarSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Render Polar Series.\n     *\n     * @returns {void}\n     * @private\n     */\n    PolarSeries.prototype.render = function (series, xAxis, yAxis, inverted) {\n        var seriesType = firstToLowerCase(series.drawType);\n        var yAxisMin = yAxis.minimum;\n        var yAxisMax = yAxis.maximum;\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n            var visiblePoint = _a[_i];\n            visiblePoint.visible = visiblePoint.visible && !((!isNullOrUndefined(yAxisMin) && visiblePoint.yValue < yAxisMin) ||\n                (!isNullOrUndefined(yAxisMax) && visiblePoint.yValue > yAxisMax));\n        }\n        if (series.points.length) {\n            if ((series.drawType.indexOf('Column') > -1)) {\n                this.columnDrawTypeRender(series, xAxis, yAxis);\n            }\n            else {\n                series.chart[seriesType + 'SeriesModule'].render(series, xAxis, yAxis, inverted);\n            }\n        }\n    };\n    /**\n     * Render Column DrawType.\n     *\n     * @returns {void}\n     * @private\n     */\n    PolarSeries.prototype.columnDrawTypeRender = function (series, xAxis, yAxis) {\n        var options;\n        var argsData;\n        var startAngle;\n        var endAngle;\n        var itemCurrentXPos;\n        var radius;\n        var inversedValue;\n        var pointStartAngle;\n        var pointEndAngle;\n        var x1;\n        var x2;\n        var y1;\n        var y2;\n        var startValue;\n        var endValue;\n        var innerRadius;\n        var min = xAxis.actualRange.min;\n        var centerX = (series.clipRect.width / 2) + series.clipRect.x;\n        var dStartX;\n        var dStartY;\n        var centerY = (series.clipRect.height / 2) + series.clipRect.y;\n        var dEndX;\n        var dEndY;\n        var isRangeColumn = series.drawType === 'RangeColumn';\n        var isPolar = series.type === 'Polar';\n        var isLogAxis = yAxis.valueType === 'Logarithmic';\n        var isStacking = series.drawType === 'StackingColumn';\n        var direction = '';\n        var sumofYValues = 0;\n        var arcValue;\n        var interval = (series.points[1] ? series.points[1].xValue : 2 * series.points[0].xValue) - series.points[0].xValue;\n        var isInverse = xAxis.isAxisInverse;\n        //customer issue ID-I249730, Polar columnSeries in OnTicks with inversed axis\n        var ticks = (xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks') ? 0 :\n            isInverse ? -interval / 2 : interval / 2;\n        var rangeInterval = xAxis.valueType === 'DateTime' ? xAxis.dateTimeInterval : 1;\n        this.getSeriesPosition(series);\n        var position = isInverse ? (series.rectCount - 1 - series.position) : series.position;\n        do {\n            sumofYValues += rangeInterval;\n            min += rangeInterval;\n        } while (min <= xAxis.actualRange.max - (xAxis.valueType === 'Category' ? 0 : 1));\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n            var point = _a[_i];\n            point.symbolLocations = [];\n            point.regions = [];\n            if (point.visible && withInRange(series.points[point.index - 1], point, series.points[point.index + 1], series)) {\n                inversedValue = isInverse ? (xAxis.visibleRange.max - point.xValue) : point.xValue - xAxis.visibleRange.min;\n                itemCurrentXPos = (inversedValue) +\n                    ((interval / series.rectCount) * position - ticks) + (sumofYValues / 360 * xAxis.startAngle);\n                itemCurrentXPos = (((itemCurrentXPos) / (sumofYValues)));\n                startAngle = 2 * Math.PI * (itemCurrentXPos + xAxis.startAngle);\n                endAngle = 2 * Math.PI * ((itemCurrentXPos + xAxis.startAngle) + (interval / series.rectCount) / (sumofYValues));\n                if (startAngle === 0 && endAngle === 0) {\n                    endAngle = 2 * Math.PI;\n                    arcValue = '1';\n                }\n                else {\n                    arcValue = '0';\n                }\n                pointStartAngle = startAngle;\n                pointEndAngle = endAngle;\n                startAngle = (startAngle - 0.5 * Math.PI) + (series.columnSpacing / 2);\n                endAngle = ((endAngle - 0.5 * Math.PI) - 0.000001) - (series.columnSpacing / 2);\n                if (isStacking || isRangeColumn) {\n                    startValue = isRangeColumn ? point.low : series.stackedValues.startValues[point.index];\n                    endValue = isRangeColumn ? point.high : series.stackedValues.endValues[point.index];\n                    endValue = (isLogAxis ? logBase(endValue === 0 ? 1 : endValue, yAxis.logBase) : endValue);\n                    endValue = endValue > yAxis.actualRange.max ? yAxis.actualRange.max : endValue;\n                }\n                else {\n                    startValue = yAxis.visibleRange.min;\n                    endValue = point.yValue > yAxis.actualRange.max ? yAxis.actualRange.max : point.yValue;\n                }\n                radius = startValue === endValue ? 0 : series.chart.radius * valueToCoefficient(endValue, yAxis);\n                x1 = centerX + radius * Math.cos(startAngle);\n                x2 = centerX + radius * Math.cos(endAngle);\n                y1 = centerY + radius * Math.sin(startAngle);\n                y2 = centerY + radius * Math.sin(endAngle);\n                innerRadius = series.chart.radius * valueToCoefficient((startValue === 0 && yAxis.visibleRange.min !== 0) ? yAxis.visibleRange.min : startValue, yAxis);\n                dStartX = centerX + innerRadius * Math.cos(startAngle);\n                dStartY = centerY + innerRadius * Math.sin(startAngle);\n                dEndX = centerX + innerRadius * Math.cos(endAngle);\n                dEndY = centerY + innerRadius * Math.sin(endAngle);\n                if (isPolar) {\n                    direction = ('M' + ' ' + x1 + ' ' + y1 + ' ' + 'A' + ' ' + radius + ' ' + radius + ' ' + '0' + ' '\n                        + arcValue + ' ' + 1 + ' ' + x2 + ' ' + y2 + ' ' + 'L' + ' ' + dEndX + ' ' + dEndY + ' ' +\n                        'A' + ' ' + innerRadius + ' ' + innerRadius + ' ' + '1' + ' ' + '0' + ' ' + '0' + ' '\n                        + dStartX + ' ' + dStartY + ' ' + 'Z');\n                }\n                else {\n                    direction = ('M' + ' ' + x1 + ' ' + y1 + ' ' + 'L' + ' ' + x2 + ' ' + y2 + ' ' + 'L '\n                        + dEndX + ' ' + dEndY + ' ' + 'L' + ' ' + dStartX + ' ' + dStartY + ' ' + 'Z');\n                }\n                point.regionData = new PolarArc(pointStartAngle, pointEndAngle, innerRadius, radius, itemCurrentXPos);\n                argsData = this.triggerEvent(series.chart, series, point);\n                options = new PathOption(series.chart.element.id + '_Series_' + series.index + '_Point_' + point.index, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, series.dashArray, direction);\n                if (!argsData.cancel) {\n                    this.appendLinePath(options, series, '');\n                    if (isPolar) {\n                        point.symbolLocations.push({\n                            x: centerX + radius * Math.cos((startAngle + (endAngle - startAngle) / 2)),\n                            y: centerY + radius * Math.sin((startAngle + (endAngle - startAngle) / 2))\n                        });\n                        if (isRangeColumn) {\n                            point.symbolLocations.push({\n                                x: centerX + innerRadius * Math.cos((startAngle + (endAngle - startAngle) / 2)),\n                                y: centerY + innerRadius * Math.sin((startAngle + (endAngle - startAngle) / 2))\n                            });\n                        }\n                    }\n                    else {\n                        point.symbolLocations.push({ x: (x1 + x2) / 2, y: (y1 + y2) / 2 });\n                        if (isRangeColumn) {\n                            point.symbolLocations.push({ x: (dEndX + dStartX) / 2, y: (dEndY + dStartY) / 2 });\n                        }\n                    }\n                }\n            }\n        }\n        this.renderMarker(series);\n        series.isRectSeries = true;\n    };\n    /**\n     * To trigger the point rendering event.\n     *\n     * @returns {void}\n     * @private\n     */\n    PolarSeries.prototype.triggerEvent = function (chart, series, point) {\n        var argsData = {\n            cancel: false, name: pointRender, series: series, point: point,\n            fill: series.setPointColor(point, series.interior),\n            border: series.setBorderColor(point, { width: series.border.width, color: series.border.color })\n        };\n        chart.trigger(pointRender, argsData);\n        point.color = argsData.fill;\n        return argsData;\n    };\n    /** get position for column drawtypes\n     *\n     * @returns {void}\n     * @private\n     */\n    PolarSeries.prototype.getSeriesPosition = function (series) {\n        var chart = series.chart;\n        var seriesCollection = [];\n        var stackingGroup = [];\n        var vSeries = { rectCount: 0, position: null };\n        for (var _i = 0, _a = chart.visibleSeries; _i < _a.length; _i++) {\n            var series_1 = _a[_i];\n            if (series_1.visible && (series_1.type === 'Polar' || series_1.type === 'Radar') && series_1.drawType.indexOf('Column') !== -1) {\n                seriesCollection.push(series_1);\n            }\n        }\n        for (var i = 0; i < seriesCollection.length; i++) {\n            var series_2 = seriesCollection[i];\n            if (series_2.drawType.indexOf('Stacking') !== -1) {\n                if (series_2.stackingGroup) {\n                    if (stackingGroup[series_2.stackingGroup] === undefined) {\n                        series_2.position = vSeries.rectCount;\n                        stackingGroup[series_2.stackingGroup] = vSeries.rectCount++;\n                    }\n                    else {\n                        series_2.position = stackingGroup[series_2.stackingGroup];\n                    }\n                }\n                else {\n                    if (vSeries.position === null) {\n                        series_2.position = vSeries.rectCount;\n                        vSeries.position = vSeries.rectCount++;\n                    }\n                    else {\n                        series_2.position = vSeries.position;\n                    }\n                }\n            }\n            else {\n                series_2.position = vSeries.rectCount++;\n            }\n        }\n        for (var i = 0; i < seriesCollection.length; i++) {\n            var value = seriesCollection[i];\n            value.rectCount = vSeries.rectCount;\n        }\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     */\n    PolarSeries.prototype.doAnimation = function (series) {\n        var duration = series.animation.duration;\n        var delay = series.animation.delay;\n        var rectElements = series.seriesElement.childNodes;\n        var count = 1;\n        if (series.drawType === 'Scatter') {\n            for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n                var point = _a[_i];\n                if (!point.symbolLocations.length || !rectElements[count]) {\n                    continue;\n                }\n                markerAnimate(rectElements[count], delay, duration, series, point.index, point.symbolLocations[0], false);\n                count++;\n            }\n        }\n        else {\n            for (count = 1; count < rectElements.length; count++) {\n                this.doPolarRadarAnimation(rectElements[count], delay, duration, series);\n            }\n        }\n    };\n    /**\n     * To do the Polar Radar draw type column animation.\n     *\n     * @returns {void}\n     * @private\n     */\n    PolarSeries.prototype.doPolarRadarAnimation = function (animateElement, delay, duration, series) {\n        var chartcenterX = series.clipRect.width / 2 + series.clipRect.x;\n        var chartcenterY = series.clipRect.height / 2 + series.clipRect.y;\n        var elementHeight = 0;\n        animateElement.style.visibility = 'hidden';\n        new Animation({}).animate(animateElement, {\n            duration: duration,\n            delay: delay,\n            progress: function (args) {\n                if (args.timeStamp > args.delay) {\n                    args.element.style.visibility = 'visible';\n                    elementHeight = ((args.timeStamp - args.delay) / args.duration);\n                    animateElement.setAttribute('transform', 'translate(' + chartcenterX\n                        + ' ' + chartcenterY + ') scale(' + elementHeight + ') translate(' + (-chartcenterX) + ' ' + (-chartcenterY) + ')');\n                }\n            },\n            end: function () {\n                animateElement.style.visibility = 'visible';\n                animateElement.removeAttribute('transform');\n                series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });\n            }\n        });\n    };\n    // path calculation for isInversed polar area series\n    PolarSeries.prototype.getPolarIsInversedPath = function (xAxis, endPoint) {\n        var vector;\n        var x1;\n        var y1;\n        var chart = this.chart;\n        var radius = chart.radius;\n        var direction = endPoint;\n        var circleRotate = xAxis.isAxisInverse ? '1 1 ' : '1 0 ';\n        vector = CoefficientToVector(valueToPolarCoefficient(xAxis.visibleLabels[0].value, xAxis), this.startAngle);\n        x1 = this.centerX + radius * vector.x;\n        y1 = this.centerY + radius * vector.y;\n        return direction += 'L ' + x1 + ' ' + y1 + ' A ' + radius + ' ' + radius + ' 0 ' + circleRotate +\n            x1 + ' ' + (this.centerY + radius) + ' A ' + radius + ' ' + radius + ' 0 ' + circleRotate + x1 + ' ' + y1 + ' ';\n    };\n    /**\n     * Get module name.\n     */\n    PolarSeries.prototype.getModuleName = function () {\n        /**\n         * Returns the module name of the series\n         */\n        return 'PolarSeries';\n    };\n    /**\n     * To destroy the polar series.\n     *\n     * @returns {void}\n     * @private\n     */\n    PolarSeries.prototype.destroy = function () {\n        /**\n         * Destroy method performed here\n         */\n    };\n    return PolarSeries;\n}(PolarRadarPanel));\nexport { PolarSeries };\n"]},"metadata":{},"sourceType":"module"}